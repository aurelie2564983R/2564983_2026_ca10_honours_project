#!/bin/bash
. <path/to/conda.sh>
conda activate xls2csv

########## Inputs #################

eh_csv=<path/to/csv>
#path to csv file containing expansion hunter output (generated by count_alleles script)
rgt_dir=<path/to/directory>/
#path to directory containing RGT output for all samples (generated by run_rgt script). Should end in a /
out_dir=<path/to/directory>/
#directory where comparison csv will be saved, should end in a /


#create/overwrite a csv file which contains the sample information

echo "Sample Name,Superpopulation,Allele 1 Length,Allele 2 Length,Het/Hom Classification,Identical Hom,RGT Allele 1 Structure,RGT Allele 1 Abundance,RGT Allele 1 Length,Same Length Allele 1,Allele 1 EH-RGT Diff.,RGT Allele 2 Structure,RGT Allele 2 Abundance,RGT Allele 2 Length,Same Length Allele 2,Allele 2 EH-RGT Diff.,EH-RGT comparison notes" | cat > $out_dir"ca10_EH_samples_RGT_comparison.csv"


##### Compare EH and RGT output for each sample #######################


#loop through every sample in the EH output csv
IFS=','
tail -n +2 $eh_csv | while read -r sample_name super_pop allele1 allele2 het_hom identical_hom
do
	#check if the sample ID is also present in the RGT file (irrespective of whether it is a human sample or human-derived cells) and whether that sample is flagged as not having an error
	sample_id=${sample_name:2}
	if grep $sample_id "$rgt_dir""ResultsSummary.csv" | grep -v -q "Error"; then
		#if there is a matching RGT record, then find the RGT output file and save allele info to variable
		input_file="$rgt_dir""FilesSpecificResults/*""$sample_id*"
		alleleA_struc=$(xlsx2csv $input_file | sed -n 2p | awk -F ',' '{print $1}' )
		alleleB_struc=$(xlsx2csv $input_file | sed -n 3p | awk -F ',' '{print $1}' )
		alleleA_abun=$(xlsx2csv $input_file | sed -n 2p | awk -F ',' '{print $2}' )
		alleleB_abun=$(xlsx2csv $input_file | sed -n 3p | awk -F ',' '{print $2}' )	
		alleleA_repeats=$(xlsx2csv $input_file | sed -n 2p | awk  -F ',' '{print $3}' )
		alleleB_repeats=$(xlsx2csv $input_file | sed -n 3p | awk  -F ',' '{print $3}' )


		#if there is no second row of data in the RGT output file, assign alleleB to be the same as alleleA
		if [ -z "$alleleB_struc" ]; then
			echo $sample_name: Only one allele found in RGT file. Setting both alleles to be identical
			eh_rgt_notes="Only one allele found in RGT file"
			#both alleles now have "equal" proportions (as they're both the same)
			per_A=50
			per_B=50
			alleleB_struc=$alleleA_struc
                        alleleB_abun=$alleleA_abun
                        alleleB_repeats=$alleleA_repeats
		else
			#calculate the total number of reads reported in the RGT file
			total_reads=$( xlsx2csv $input_file | awk -F ',' '{x+=$2}END{print x}' )
			
			#calculate the number of reads supporting sequences with the same length as allele A and B
			alleleA_reads=$( xlsx2csv $input_file | awk -v alleleA_repeats="$alleleA_repeats" -F ',' '$3 == alleleA_repeats' | awk -F ',' '{x+=$2}END{print x}')
			alleleB_reads=$( xlsx2csv $input_file | awk -v alleleB_repeats="$alleleB_repeats" -F ',' '$3 == alleleB_repeats' | awk -F ',' '{x+=$2}END{print x}')
			
			#calculate the percentage of reads which have allele A or allele B length
			per_A=$( echo "scale=0;$alleleA_reads*100/$total_reads" | bc)
			per_B=$( echo "scale=0;$alleleB_reads*100/$total_reads" | bc)
			per_B_struc=$( echo "scale=0;$alleleB_abun*100/$total_reads" | bc)
		fi





		if (( $(echo "$per_A >= 80"| bc -l) )); then
			#if alleleA is supported by more than 80% of the reads, both allleles are the same length. Then need to check if there is evidence for one of the alleles having an interruption
			if [ $alleleA_repeats -eq $alleleB_repeats -a $per_B_struc -ge 20 ]; then
			       #if the two alleles are the same length, it means they must differ in interruptions. If alleleB is supported by more than 20% of reads, the differences are probably not due to sequencing errors	
				echo $sample_name: Allele A and B have identical lengths but different structures
				eh_rgt_notes="Two alleles with identical lengths but different structure"
			else
				#echo $sample_name: Allele A and B are likely to be identical. Setting allele A info for both alleles
				eh_rgt_notes="Two identical alleles"
				alleleB_struc=$alleleA_struc
	                        alleleB_abun=$alleleA_abun
	                        alleleB_repeats=$alleleA_repeats
			fi
		elif (( $(echo "$per_B >= 20"| bc -l) )); then
			#echo Allele B is supported by more than 20% of reads, so is likely to be a true allele
			eh_rgt_notes=""
		else
			#check if adding one repeat size above and below the alleleB repeat lengths gives enough reads for alleleB to be supported by more than 20% of reads
			alleleB_plus=$(($alleleB_repeats+1))
			alleleB_minus=$(($alleleB_repeats-1))
			if [ $alleleB_plus -eq $alleleA_repeats -o $alleleB_minus -eq $alleleA_repeats ]; then
				#check if alleleB_plus or alleleB minus is the same as alleleA. If yes, set alleleA as alleleB
				if [ $per_A -le 50 ]; then
					echo $sample_name: Allele A is supported by $per_A% of reads, but alleleB is +-1 repeat length of allele A. Setting allele A info for both alleles
					eh_rgt_notes="Please check sample manually. Low number of supporting reads but likely two RGT alleles within 1 repeat unit of each other. Set two alleles to identical"
				else
					eh_rgt_notes="Two RGT alleles within 1 repeat unit of each other. Set two alleles to identical"
				fi
				alleleB_struc=$alleleA_struc
				alleleB_abun=$alleleA_abun
				alleleB_repeats=$alleleA_repeats


			else
				#set to 0 as default for when no reads are read
				alleleB_plusreads=$( xlsx2csv $input_file | awk -v alleleB_plus="$alleleB_plus" -F ',' '$3 == alleleB_plus' | awk -F ',' '{x+=$2}END{print x}')
				alleleB_minusreads=$( xlsx2csv $input_file | awk -v alleleB_minus="$alleleB_minus" -F ',' '$3 == alleleB_minus' | awk -F ',' '{x+=$2}END{print x}')
				#if alleleB_plusreads or alleleB_minusreads are empty, set them to 0
				if [ -z "$alleleB_plusreads" ]; then
					alleleB_plusreads=0
				fi

				if [ -z "$alleleB_minusreads" ]; then
					alleleB_minusreads=0
				fi

				per_B_plus_minus=$( echo "scale=0;($alleleB_reads+$alleleB_plusreads+$alleleB_minusreads)*100/$total_reads" | bc -l)
			

				if (( $(echo "$per_B_plus_minus >= 20"| bc -l) )); then
			       		#echo $sample_name: Allele B plus minus one repeat unit is supported by $per_B_plus_minus % of reads. Might be a true allele, but worth checking
					eh_rgt_notes="Probably two unique alleles. Check manually"
				else
					echo $sample_name: Please check sample manually. Allele A is supported by $per_A % of reads, allele B is supported by $per_B % of reads
					eh_rgt_notes="Cannot reliably find RGT lengths. Check manually"
				fi	
			fi
			
			
			
			
		fi


		#check what the biggest allele reported by RGT is
		#max_repeat=$( xlsx2csv $input_file | tail -1 | awk -F ',' '{if(NF>2 && $3>M){M=$3;print $3} }' )
		max_repeat=$( xlsx2csv $input_file | awk -F ',' -v MAX=0 '{ if(NR>1 && $3>MAX){MAX=$3}} END{print MAX}' )
		max_repeat_min=$(($max_repeat-10))
		#check which allele is the largest allele, then check the difference between the largest RGT repeat size and the largest allele
		if [ $alleleA_repeats -lt $alleleB_repeats ]; then
			#if alleleB is the largest allele, check against alleleB
			repeat_diff_B=$(($max_repeat-$alleleB_repeats))
			if [ $repeat_diff_B -ge 10 ]; then
				max_repeat_abun=$( xlsx2csv $input_file | awk -v max_repeat_min="$max_repeat_min" -F ',' '($3 > max_repeat_min){print $2}' | awk -F ',' '{x+=$1}END{print x}')
				max_repeat_abun_per=$( echo "scale=0;($max_repeat_abun)*100/$total_reads" | bc -l)
				if [ $max_repeat_abun -gt 1 -a $max_repeat_abun_per -ge 20 ]; then
					#if the large allele is supported by more than one read and more than 20% of reads, then assign
					echo $sample_name: Difference between the largest allele found by RGT and Allele 2 is $repeat_diff_B
					#set most abundant allele near the max allele size to allele B
					alleleB_struc=$( xlsx2csv $input_file | tail -n +2 | awk -F ',' -v max_repeat_min=$max_repeat_min '($3 > max_repeat_min){print $1}' | head -1 )
                                	alleleB_abun=$( xlsx2csv $input_file | tail -n +2 | awk -F ',' -v max_repeat_min=$max_repeat_min '($3 > max_repeat_min){print $2}' | head -1 )
                                	alleleB_repeats=$( xlsx2csv $input_file | tail -n +2 | awk -F ',' -v max_repeat_min=$max_repeat_min '($3 > max_repeat_min){print $3}' | head -1 )
					eh_rgt_notes="Check manually. 10+ repeat unit difference. Large allele assigned"
				else
					eh_rgt_notes="Check manually. 10+ repeat unit difference. Large allele not assigned"
				fi
			fi
		else
			#check against alleleA
			repeat_diff_A=$(($max_repeat-$alleleA_repeats))
			if [ $repeat_diff_A -ge 10 ]; then
				max_repeat_abun=$( xlsx2csv $input_file | awk -v max_repeat_min="$max_repeat_min" -F ',' '($3 > max_repeat_min){print $2}' | awk -F ',' '{x+=$1}END{print x}')
                                max_repeat_abun_per=$( echo "scale=0;($max_repeat_abun)*100/$total_reads" | bc -l)
				if [ $max_repeat_abun -gt 1 -a $max_repeat_abun_per -ge 20 ]; then
					#if the large allele is supported by more than one read and by more than 20% of reads, then assign
			       		echo $sample_name: Difference between the largest allele found by RGT and Allele 2 is $repeat_diff_A
					#set most abundant allele near the max allele size to allele B
					eh_rgt_notes="Check manually. 10+ repeat unit difference. Large allele assigned"
					alleleB_struc=$( xlsx2csv $input_file | tail -n +2 | awk -F ',' -v max_repeat_min=$max_repeat_min '($3 > max_repeat_min){print $1}' | head -1 )
					alleleB_abun=$( xlsx2csv $input_file | tail -n +2 | awk -F ',' -v max_repeat_min=$max_repeat_min '($3 > max_repeat_min){print $2}' | head -1 )
					alleleB_repeats=$( xlsx2csv $input_file | tail -n +2 | awk -F ',' -v max_repeat_min=$max_repeat_min '($3 > max_repeat_min){print $3}' | head -1 )
				else
					eh_rgt_notes="Check manually. 10+ repeat unit difference. Large allele not assigned"
				fi
			fi
		fi




		allele1=$((allele1))
		allele2=$((allele2))
		
		#check if alleleA is smaller than alleleB. If yes, call alleleA allele1
		if [ $alleleA_repeats -lt $alleleB_repeats ]; then
			#compare RGT alleleA to EH allele1 and check if they're roughly the same size
			if [ $allele1 -eq $alleleA_repeats ]; then
				one_same="True"
			else
				one_same="False"
			fi

			#do the same for alleleB
			if [ $allele2 -eq $alleleB_repeats ]; then
	                	two_same="True"
			else
				two_same="False"
			fi
		#append the sequence structure, abundance and number of repeats units for the two most common alleles
		allele1_diff=$(($alleleA_repeats-$allele1))
		allele2_diff=$(($alleleB_repeats-$allele2))	
		echo "$sample_name"",""$super_pop"",""$allele1"",""$allele2"",""$het_hom"",""$identical_hom"",""$alleleA_struc"",""$alleleA_abun"",""$alleleA_repeats"",""$one_same"",""$allele1_diff"",""$alleleB_struc"",""$alleleB_abun"",""$alleleB_repeats"",""$two_same"",""$allele2_diff"",""$eh_rgt_notes" >> $out_dir"ca10_EH_samples_RGT_comparison.csv"





		else
			#assume B is the smallest allele (or both are the same size), and so assign alleleB as allele1 for the RGT output
			if [ $allele1 -eq $alleleB_repeats ]; then
				one_same="True"
			else
				one_same="False"
			fi
             		
			#do the same for alleleA
			if [ $allele2 -eq $alleleA_repeats ]; then
				two_same="True"
			else
				two_same="False"
			fi

			#append the allele B info as allele1
			allele1_diff=$(($alleleB_repeats-$allele1))
			allele2_diff=$((alleleA_repeats-$allele2))
			echo "$sample_name"",""$super_pop"",""$allele1"",""$allele2"",""$het_hom"",""$identical_hom"",""$alleleB_struc"",""$alleleB_abun"",""$alleleB_repeats"",""$one_same"",""$allele1_diff"",""$alleleA_struc"",""$alleleA_abun"",""$alleleA_repeats"",""$two_same"",""$allele2_diff"",""$eh_rgt_notes" >> $out_dir"ca10_EH_samples_RGT_comparison.csv"
	
		fi

	else
		if grep $sample_id "$rgt_dir""ResultsSummary.csv" | grep -q "Error"; then
			#if there is an error in the RGT file for this sample, state this in the comparison notes
			echo "$sample_name"",""$super_pop"",""$allele1"",""$allele2"",""$het_hom"",""$identical_hom"",""-"",""-"",""-"",""-"",""-"",""-"",""-"",""-"",""-"",""-"",""RGT Error" >> $out_dir"ca10_EH_samples_RGT_comparison.csv"
		else

		#else append N/A to the lines for the number of fields that would otherwise have been filled in by the RGT data and comparison
		
			echo "$sample_name"",""$super_pop"",""$allele1"",""$allele2"",""$het_hom"",""$identical_hom"",""-"",""-"",""-"",""-"",""-"",""-"",""-"",""-"",""-"",""-"",""" >> $out_dir"ca10_EH_samples_RGT_comparison.csv"
		fi
	fi
done

echo Finished comparing RGT and EH output at `date`


#check that none of the rows have too many columns (e.g. those generated by errors or incorrect formatting)

awk -F, 'NF<=17' $out_dir"ca10_EH_samples_RGT_comparison.csv" > $out_dir"ca10_EH_samples_RGT_comparison_formatted.csv"

wc -l $out_dir"ca10_EH_samples_RGT_comparison_formatted.csv"
wc -l $out_dir"ca10_EH_samples_RGT_comparison.csv"
####### Output Summary #######################


# print the number of matched and unmatched and undetermined RGT and EH output alleles to a summary file

echo "run_compare_eh_rgt_output_v1.1.sh was run at `date`" > $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"
echo "" >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"
echo "" >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"
echo "Number of matching EH and RGT output alleles ( - means no RGT data was available)" >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"
echo "" >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"
tail -n +2 $out_dir"ca10_EH_samples_RGT_comparison.csv" | cut -f 10,15 -d, | tr , '\n' | sort -n | uniq -c | sed 's|^ *\([0-9]*\) \(.*\)|\u\2: \1|g' >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"
echo "" >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"
echo "" >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"
echo Number of instances of RGT allele lengths which were found to match or not match to EH length >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"
echo "" >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"
tail -n +2 $out_dir"ca10_EH_samples_RGT_comparison.csv" | awk -F , -v OFS=, '{print $10, $9, $15, $14}' | sed 's/,/\n/2;P;D;' | sort -V | uniq -c | sed 's|^ *\([0-9]*\) \(.*\)|\u\2: \1|g' >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"

echo "" >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"
echo "" >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"


echo "Number of RGT alleles in each superpopulation analysed" >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"
tail -n +2 $out_dir"ca10_EH_samples_RGT_comparison.csv" | awk -F , -v OFS=, '{print $2, $2 }' | tr , '\n' | sort -V | uniq -c | sed 's|^ *\([0-9]*\) \(.*\)|\u\2: \1|g' >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"
echo "" >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"
echo "" >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"

echo "Number of alleles with sequence interruptions" >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"
echo "" >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"

echo "Number of alleles with CAT interruption" >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"
echo "" >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"
tail -n +2 $out_dir"ca10_EH_samples_RGT_comparison.csv" | awk -F , -v OFS=, '{print $2, $7, $2, $12}' | sed 's/,/\n/2;P;D;' | grep "CAT" | awk -F , -v OFS=, '{print $1}' | sort -V | uniq -c | sed 's|^ *\([0-9]*\) \(.*\)|\u\2: \1|g' >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"
echo "" >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"
tail -n +2 $out_dir"ca10_EH_samples_RGT_comparison.csv" | awk -F , -v OFS=, '{print $2, $7, $9, $2, $12, $14}' | sed 's/,/\n/3;P;D;' | grep "CAT" | awk -F , -v OFS=, '{print $1, $3}' | sort -V | uniq -c | sed 's|^ *\([0-9]*\) \(.*\)|\u\2: \1|g' >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"
echo "" >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"


echo "Number of alleles with CAC interruption" >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"
tail -n +2 $out_dir"ca10_EH_samples_RGT_comparison.csv" | awk -F , -v OFS=, '{print $2, $7, $2, $12}' | sed 's/,/\n/2;P;D;' | grep "CAC" | awk -F , -v OFS=, '{print $1}' | sort -V | uniq -c | sed 's|^ *\([0-9]*\) \(.*\)|\u\2: \1|g' >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"
echo "" >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"
tail -n +2 $out_dir"ca10_EH_samples_RGT_comparison.csv" | awk -F , -v OFS=, '{print $2, $7, $9, $2, $12, $14}' | sed 's/,/\n/3;P;D;' | grep "CAC" | awk -F , -v OFS=, '{print $1, $3}' | sort -V | uniq -c | sed 's|^ *\([0-9]*\) \(.*\)|\u\2: \1|g' >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"
echo "" >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"

echo "Number of alleles with CGG interruption" >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"
tail -n +2 $out_dir"ca10_EH_samples_RGT_comparison.csv" | awk -F , -v OFS=, '{print $2, $7, $2, $12}' | sed 's/,/\n/2;P;D;' | grep "CGG" | awk -F , -v OFS=, '{print $1}' | sort -V | uniq -c | sed 's|^ *\([0-9]*\) \(.*\)|\u\2: \1|g' >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"
echo "" >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"
tail -n +2 $out_dir"ca10_EH_samples_RGT_comparison.csv" | awk -F , -v OFS=, '{print $2, $7, $9, $2, $12, $14}' | sed 's/,/\n/3;P;D;' | grep "CGG" | awk -F , -v OFS=, '{print $1, $3}' | sort -V | uniq -c | sed 's|^ *\([0-9]*\) \(.*\)|\u\2: \1|g' >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"
echo "" >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"




echo "Number of alleles with CCG interruption" >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"
tail -n +2 $out_dir"ca10_EH_samples_RGT_comparison.csv" | awk -F , -v OFS=, '{print $2, $7, $2, $12}' | sed 's/,/\n/2;P;D;' | grep "CCG" | awk -F , -v OFS=, '{print $1}' | sort -V | uniq -c | sed 's|^ *\([0-9]*\) \(.*\)|\u\2: \1|g' >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"
echo "" >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"
tail -n +2 $out_dir"ca10_EH_samples_RGT_comparison.csv" | awk -F , -v OFS=, '{print $2, $7, $9, $2, $12, $14}' | sed 's/,/\n/3;P;D;' | grep "CCG" | awk -F , -v OFS=, '{print $1, $3}' | sort -V | uniq -c | sed 's|^ *\([0-9]*\) \(.*\)|\u\2: \1|g' >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"
echo "" >> $out_dir"ca10_EH_samples_RGT_comparison_summary.txt"


# Output a summary file containing the 20 most common allelle structures

echo "Number of times each allele structure is found in the 1000 ONT samples alleles" > $out_dir"ca10_common_RGT_alleles.txt"
tail -n +2 $out_dir"ca10_EH_samples_RGT_comparison_formatted.csv" | awk -F , -v OFS=, '{print $7, $12}' | sed 's/,/\n/1;P;D;' | sort -V | uniq -c | sort -k2 -n -r | sed 's|^ *\([0-9]*\) \(.*\)|\u\2: \1|g' | grep -v "-" >> $out_dir"ca10_common_RGT_alleles.txt"





conda deactivate




###### Make Plots ####


conda activate matplotlib

csv_file=$out_dir"ca10_EH_samples_RGT_comparison_formatted.csv"
#define path to the csv file that should be loaded in
out_dir="$out_dir""_plots"
##file path to location where plots should be saved. should NOT end in a /


python <<EOF
#import necessary packages, make a full_df which contains all the data (including for samples where long read data is not available) and make a new dataframe that contains only samples that also have RGT data, and define numerical columns as integers
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.ticker import MaxNLocator
import scipy.stats as sps




full_df = pd.read_csv("$csv_file")
df = full_df[full_df['RGT Allele 2 Length'] != '-']
ignore = ['Sample Name', 'Superpopulation', 'Het/Hom Classification', 'Identical Hom', 'RGT Allele 1 Structure', 'Same Length Allele 1', 'RGT Allele 2 Structure', 'Same Length Allele 2', 'EH-RGT comparison notes']

df = (df.set_index(ignore, append=True)
        .astype(int)
        .reset_index(ignore)
       )
full_df['Allele 1 Length'].astype(int)
full_df['Allele 2 Length'].astype(int)

df['Identical Hom'].astype(bool)
df['Same Length Allele 1'].astype(bool)
df['Same Length Allele 2'].astype(bool)

#create scatterplot of EH vs RGT output

fig = plt.figure()
ax1 = fig.add_subplot(111)
color_dict = { 'False':'m', 'True':'c' }
ax1.scatter(df['Allele 1 Length'], df['RGT Allele 1 Length'], s=10, color=[ color_dict[i] for i in df['Same Length Allele 1'] ])
ax1.scatter(df['Allele 2 Length'], df['RGT Allele 2 Length'], s=10,  color=[ color_dict[i] for i in df['Same Length Allele 2'] ])
plt.xlabel("Short-Read Repeat Estimate (Number of Repeats)")
plt.ylabel("Long-Read Repeat Estimate (Number of Repeats)")
ax1.set_ylim(0,150)
ax1.set_xlim(0,150)
plt.legend(['Same Length', 'Different Length'])
#plt.title('Short- vs. Long-Read Repeat Length Estimates')
ax1.spines['top'].set_visible(False)
ax1.spines['right'].set_visible(False)
plt.savefig('$out_dir/plots/EH_RGT_length_comparison.png')


#Loop through every superpopulation and make summary graphs for each
#define arrays
het_per=[]
long_hom_per=[]
short_hom_per=[]
superpops=['AFR', 'AMR', 'EAS', 'EUR', 'SAS']
colours=['g','m','b','y','c']
count=0
for x in superpops:
	superpop_df = df[df['Superpopulation'] == x]
	full_superpop_df = full_df[full_df['Superpopulation'] == x]
	#combine the allele 1 and allele 2 lengths
	eh_alleles=full_superpop_df['Allele 1 Length'].append(full_superpop_df['Allele 2 Length'])
	rgt_alleles=superpop_df['RGT Allele 1 Length'].append(superpop_df['RGT Allele 2 Length'])

	#plot the number of EH and RGT alleles found for every length

	fig = plt.figure()
	ax1 = fig.add_subplot(111)
	binwidth = 1
	plt.hist(eh_alleles, bins=range(0, 60 + binwidth, binwidth), histtype='barstacked', label='EH', color=colours[count])
	plt.xlabel("Number of Repeats")
	plt.ylabel("Number of Alleles")
	plt.title(f'{x}')
	plt.savefig(f'$out_dir/plots/{x}_EH_allele_histogram.png')


	
	fig = plt.figure()
	ax1 = fig.add_subplot(111)
	binwidth = 1
	plt.hist(rgt_alleles, bins=range(0, 150 + binwidth, binwidth), histtype='barstacked', label='RGT', color=colours[count])
	plt.xlabel("Number of Repeats")
	plt.ylabel("Number of Alleles")
	ax1.set_ylim(0,100)
	plt.title(f'{x}')
	plt.savefig(f'$out_dir/plots/{x}_RGT_allele_histogram.png')

	count=count+1

	#count total number of samples and samples for with each classification for each superpopulation. append the percentages of each classification to an array
	eh_superpop=full_df[full_df['Superpopulation'] == x]
	total_samples=len(eh_superpop)
	het_df=eh_superpop.loc[eh_superpop['Het/Hom Classification'] == 'het' ]
	long_hom_df=eh_superpop.loc[eh_superpop['Het/Hom Classification'] == 'long_hom' ]
	short_hom_df=eh_superpop.loc[eh_superpop['Het/Hom Classification'] == 'short_hom' ]
	het=len(het_df)
	long_hom=len(long_hom_df)
	short_hom=len(short_hom_df)
	het_per.append(100*het/total_samples)
	long_hom_per.append(100*long_hom/total_samples)
	short_hom_per.append(100*short_hom/total_samples)
plt.close('all')
r = [0,1,2,3,4]
plt.bar(r,short_hom_per, width=0.85, color='g')
plt.bar(r,het_per, bottom=short_hom_per, width=0.85, color='#1F77B4')
plt.bar(r,long_hom_per, bottom=[i+j for i,j in zip(short_hom_per, het_per)], width=0.85, color='m')
plt.xticks(r,superpops)
plt.xlabel("Superpopulation")
plt.ylabel("Percentage of Samples")
plt.title('Short-Read Het/Hom Classifications')
plt.legend(['Unexpanded Homozygote', 'Heterozygote', 'Expanded Homozygote'])
plt.savefig(f'$out_dir/plots/het_hom_classifications.png')




#allele lengths of samples with the different interruptions, and colour stacked histogram by superpop


#make a dataframe containing the necessary data

superpop=df['Superpopulation'].append(df['Superpopulation'])
rgt_alleles=df['RGT Allele 1 Length'].append(df['RGT Allele 2 Length'])
rgt_allele_struc=df['RGT Allele 1 Structure'].append(df['RGT Allele 2 Structure'])
rgt_alleles_data = {
	'Superpopulation' : superpop,
	'RGT Allele Length' : rgt_alleles,
	'RGT Allele Structure' : rgt_allele_struc
}
rgt_alleles_df = pd.DataFrame(rgt_alleles_data)



interruption=['CAC', 'CAT', 'CGG', 'CCG']

for i in interruption:

	#pull out the alleles that contain each interruption	
	interrupted_alleles = rgt_alleles_df[rgt_alleles_df['RGT Allele Structure'].str.contains(i)]

	#then pull out the samples from each superpop containing the interruption
	interrupted_alleles_superpop=[]
	for x in superpops:
		interrupted_alleles_superpop.append(interrupted_alleles.loc[interrupted_alleles['Superpopulation'] == x, 'RGT Allele Length'])
	
	
	#make a stacked histogram showing the allele lengths where every interruption occurs, and which superpopulation the samples are from

	fig = plt.figure()
	ax1 = fig.add_subplot(111)
	plt.hist(interrupted_alleles_superpop, bins=range(0, 150 + binwidth, binwidth), stacked=True)
	binwidth = 1
	plt.xlabel("Number of Repeats")
	plt.ylabel("Number of Alleles")
	ax1.set_xlim(0,150)
	plt.title(f'Number of Alleles Containing {i}')
	plt.legend(superpops)
	plt.savefig(f'$out_dir/plots/{i}_interruption_alleles.png')

	plt.close('all') 




#plot number of times each interruption occurs

no_interruptions = rgt_alleles_df

for i in interruption:
	#make sure alleles aren't classified as having more than one interruption
	
	interrupted_alleles=(no_interruptions[no_interruptions['RGT Allele Structure'].str.contains(i)])
	no_interruptions=no_interruptions[~no_interruptions['RGT Allele Structure'].str.contains(i)]

	#count how many times the interruption occurs in each allele
	
	interrupted_alleles['Number of Interruptions'] = list(map(lambda x: x.count(i), interrupted_alleles['RGT Allele Structure']))
	count=0
	
	fig = plt.figure()
	ax1 = fig.add_subplot(111)
	plt.xlabel("Total Repeat Units")
	plt.ylabel(f'Number of {i} Interruptions')
	ax1.set_xlim(0,150)
	#plt.title(f'Number of {i} Interruptions vs Total Repeat Length')
	plt.title(f'{i}')
	ax1.spines['top'].set_visible(False)
	ax1.spines['right'].set_visible(False)
	#add on the samples from each superpopulation as a different colour
	for x in superpops:
		interrupted_superpop=interrupted_alleles[interrupted_alleles['Superpopulation'].str.contains(x)]
		ax1.scatter(interrupted_superpop['RGT Allele Length'], interrupted_superpop['Number of Interruptions'], s=100, color=colours[count], label=x, alpha=0.5, edgecolors='none'  )
		count=count+1

	#plot scatter graph
	ax1.set_ylim(ymin=0)
	ax1.yaxis.set_major_locator(MaxNLocator(integer=True))
	plt.legend(title="Superpopulation")
	plt.savefig(f'$out_dir/plots/{i}_interruption_length_comparison.png')
	

	print(i)
	df_correlation = interrupted_alleles[['RGT Allele Length','Number of Interruptions']]
	x=interrupted_alleles['RGT Allele Length'].to_numpy()
	y=interrupted_alleles['Number of Interruptions'].to_numpy()
	pearson, p = sps.pearsonr(x, y)
	print("Pearson:",pearson)
	print("p-value:",p)
	print("")




# then make graphs where all allele lengths are plotted for each superpopulation, but the bars are stacked and coloured by whether or not there are interruptions in the alleles


for x in superpops:
	#pull out all samples for every superpopulation
	superpop_alleles=rgt_alleles_df[rgt_alleles_df['Superpopulation'].str.contains(x)]
	superpop_interrupted=[]
	no_interruptions=superpop_alleles

	#then pull out samples containing interruptions, and remove all alleles containing these interruptions from the no_interruptions dataframe
	for i in interruption:
		interup_alleles=(no_interruptions[no_interruptions['RGT Allele Structure'].str.contains(i)])
		superpop_interrupted.append(interup_alleles['RGT Allele Length'])
		no_interruptions=no_interruptions[~no_interruptions['RGT Allele Structure'].str.contains(i)]
	superpop_interrupted.insert(0, no_interruptions['RGT Allele Length'])

	
	#make a figure to show the lengths and the interruptions present
	
	fig = plt.figure(figsize=(12,2))
	ax1 = fig.add_subplot(111)
	plt.hist(superpop_interrupted, bins=range(35, 150 + binwidth, binwidth), stacked=True)
	binwidth = 1
	ax1.spines['top'].set_visible(False)
	ax1.yaxis.set_major_locator(MaxNLocator(integer=True))
	ax1.spines['right'].set_visible(False)
	plt.legend(['No Interruption', 'CAT[CAG]1CAC', '[CAG]nCAT[CAG]n', 'CGG', 'CCG'])
	#plt.xlabel("Number of Repeats")
	#plt.ylabel("Number of Alleles")
	#ax1.set_xlim(35,150)
	#plt.title(f'{x}')
	plt.savefig(f'$out_dir/plots/{x}_rgt_allele_lengths_interruptions.png')
	plt.close('all')	







	# make a histogram showing Nehaa's PCR lengths
	pcr_alleles = pd.read_csv("/home/aurelie/erda1_project/output_and_results/NehaasERDA1repeatSizesIn383Enroll-HDparticipants_anonymised.csv")
	fig = plt.figure(figsize=(5,2))
	ax1 = fig.add_subplot(111)
	binwidth = 1
	plt.hist(pcr_alleles, bins=range(0, 90 + binwidth, binwidth), histtype='barstacked', label='PCR', color='y')
	plt.xlabel("Number of Repeats")
	plt.ylabel("Number of Alleles")
	plt.title(f'PCR Allele Lengths')
	plt.savefig(f'$out_dir/plots/nehaa_pcr_allele_histogram.png')

EOF


conda deactivate
